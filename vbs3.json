{
  "start": "Program",
  "lex": {
    "rules": [
      [
        "\\n+",
        " return 'tNL'; "
      ],
      [
        "[ \\t]+",
        "/* skip whitespace */"
      ],
      [
        "Function\\b",
        " return 'tFUNCTION'; "
      ],
      [
        "If\\b",
        " return 'tIF'; "
      ],
      [
        "Then\\b",
        " return 'tTHEN'; "
      ],
      [
        "[<>\\(\\)=]",
        " return yytext; "
      ],
      [
        "<",
        " return '<'; "
      ],
      [
        ">",
        " return '>'; "
      ],
      [
        "\\(",
        " return '('; "
      ],
      [
        "\\)",
        " return ')'; "
      ],
      [
        ",",
        " return 'COMMA'; "
      ],
      [
        "\\w\\w+",
        " return 'tIdentifier'; "
      ],
      [
        "$",
        "return 'tEOF';"
      ]
    ]
  },
  "bnf": {
    "Program": [
      [
        "OptionExplicit_opt SourceElements tEOF",
        " parse_complete($1); "
      ]
    ],
    "OptionExplicit_opt": [
      [
        "",
        " $$ = false; "
      ],
      [
        "tOPTION tEXPLICIT tNL",
        " $$ = true; "
      ]
    ],
    "SourceElements": [
      "",
      [
        "SourceElements StatementNl",
        " source_add_statement(ctx, $2); "
      ],
      [
        "SourceElements ClassDeclaration",
        " source_add_class(ctx, $2); "
      ]
    ],
    "StatementsNl_opt": [
      [
        "",
        " $$ = null; "
      ],
      [
        "StatementsNl",
        " $$ = $1; "
      ]
    ],
    "StatementsNl": [
      [
        "StatementNl",
        " $$ = $1; "
      ],
      [
        "StatementNl StatementsNl",
        " $$ = link_statements($1, $2); "
      ]
    ],
    "StatementNl": [
      [
        "Statement tNL",
        " $$ = $1; "
      ]
    ],
    "Statement": [
      [
        ":",
        " $$ = null; "
      ],
      [
        ": Statement",
        " $$ = $2; "
      ],
      [
        "SimpleStatement",
        " $$ = $1; "
      ],
      [
        "SimpleStatement : Statement",
        " $$ = $1; "
      ],
      [
        "SimpleStatement :",
        " $$ = $1; "
      ]
    ],
    "SimpleStatement": [
      [
        "MemberExpression ArgumentList_opt",
        " $$ = new_call_statement(ctx, $1); ; "
      ],
      [
        "tCALL MemberExpression Arguments_opt",
        " $$ = new_call_statement(ctx, $2); ; "
      ],
      [
        "MemberExpression Arguments_opt = Expression",
        " $$ = new_assign_statement(ctx, $1, $4); ; "
      ],
      [
        "tDIM DimDeclList",
        " $$ = new_dim_statement(ctx, $2); ; "
      ],
      [
        "IfStatement",
        " $$ = $1; "
      ],
      [
        "tWHILE Expression tNL StatementsNl_opt tWEND",
        " $$ = new_while_statement(ctx, STAT_WHILE, $2, $4); ; "
      ],
      [
        "tDO DoType Expression tNL StatementsNl_opt tLOOP",
        " $$ = new_while_statement(ctx, $2 ? STAT_WHILELOOP : STAT_UNTIL, $3, $5);\n                                              ; "
      ],
      [
        "tDO tNL StatementsNl_opt tLOOP DoType Expression",
        " $$ = new_while_statement(ctx, $5 ? STAT_DOWHILE : STAT_DOUNTIL, $6, $3);\n                                              ; "
      ],
      [
        "FunctionDecl",
        " $$ = new_function_statement(ctx, $1); ; "
      ],
      [
        "tEXIT tDO",
        " $$ = new_statement(ctx, STAT_EXITDO, 0); ; "
      ],
      [
        "tEXIT tFOR",
        " $$ = new_statement(ctx, STAT_EXITFOR, 0); ; "
      ],
      [
        "tEXIT tFUNCTION",
        " $$ = new_statement(ctx, STAT_EXITFUNC, 0); ; "
      ],
      [
        "tEXIT tPROPERTY",
        " $$ = new_statement(ctx, STAT_EXITPROP, 0); ; "
      ],
      [
        "tEXIT tSUB",
        " $$ = new_statement(ctx, STAT_EXITSUB, 0); ; "
      ],
      [
        "tSET MemberExpression Arguments_opt = Expression",
        " $$ = new_set_statement(ctx, $2, $5); ; "
      ],
      [
        "tSTOP",
        " $$ = new_statement(ctx, STAT_STOP, 0); ; "
      ],
      [
        "tON tERROR tRESUME tNEXT",
        " $$ = new_onerror_statement(ctx, TRUE); ; "
      ],
      [
        "tON tERROR tGOTO 0",
        " $$ = new_onerror_statement(ctx, FALSE); ; "
      ],
      [
        "tCONST ConstDeclList",
        " $$ = new_const_statement(ctx, $2); ; "
      ],
      [
        "tFOR tIdentifier = Expression tTO Expression Step_opt tNL StatementsNl_opt tNEXT",
        " $$ = new_forto_statement(ctx, $2, $4, $6, $7, $9); ; "
      ],
      [
        "tFOR tEACH tIdentifier tIN Expression tNL StatementsNl_opt tNEXT",
        " $$ = new_foreach_statement(ctx, $3, $5, $7); "
      ]
    ],
    "MemberExpression": [
      [
        "tIdentifier",
        " $$ = new_member_expression(null, $1); "
      ],
      [
        "CallExpression . tIdentifier",
        " $$ = new_member_expression($1, $3); "
      ]
    ],
    "DimDeclList": [
      [
        "tIdentifier",
        " $$ = new_dim_decl(ctx, $1, null); ; "
      ],
      [
        "tIdentifier , DimDeclList",
        " $$ = new_dim_decl(ctx, $1, $3); ; "
      ]
    ],
    "ConstDeclList": [
      [
        "ConstDecl",
        " $$ = $1; "
      ],
      [
        "ConstDecl , ConstDeclList",
        " $$ = $1; "
      ]
    ],
    "ConstDecl": [
      [
        "tIdentifier = LiteralExpression",
        " $$ = new_const_decl(ctx, $1, $3); ; "
      ]
    ],
    "DoType": [
      [
        "tWHILE",
        " $$ = TRUE; "
      ],
      [
        "tUNTIL",
        " $$ = FALSE; "
      ]
    ],
    "Step_opt": [
      [
        "",
        " $$ = null;"
      ],
      [
        "tSTEP Expression",
        " $$ = $2; "
      ]
    ],
    "IfStatement": [
      [
        "tIF Expression tTHEN tNL StatementsNl ElseIfs_opt Else_opt tEND tIF",
        " $$ = new_if_statement(ctx, $2, $5, $6, $7); ; "
      ],
      [
        "tIF Expression tTHEN Statement",
        " $$ = new_if_statement(ctx, $2, $4, null, null); ; "
      ],
      [
        "tIF Expression tTHEN Statement tELSE Statement",
        " $$ = new_if_statement(ctx, $2, $4, null, $6); ; "
      ]
    ],
    "ElseIfs_opt": [
      [
        "",
        " $$ = null; "
      ],
      [
        "ElseIfs",
        " $$ = $1; "
      ]
    ],
    "ElseIfs": [
      [
        "ElseIf",
        " $$ = $1; "
      ],
      [
        "ElseIf ElseIfs",
        "  $$ = $1; "
      ]
    ],
    "ElseIf": [
      [
        "tELSEIF Expression tTHEN tNL StatementsNl",
        " $$ = new_elseif_decl(ctx, $2, $5); "
      ]
    ],
    "Else_opt": [
      [
        "",
        " $$ = null; "
      ],
      [
        "tELSE tNL StatementsNl",
        " $$ = $3; "
      ]
    ],
    "Arguments_opt": [
      [
        "EmptyBrackets_opt",
        " $$ = null; "
      ],
      [
        "( ArgumentList )",
        " $$ = $2; "
      ]
    ],
    "ArgumentList_opt": [
      [
        "EmptyBrackets_opt",
        " $$ = null; "
      ],
      [
        "ArgumentList",
        " $$ = $1; "
      ]
    ],
    "ArgumentList": [
      [
        "Expression",
        " $$ = $1; "
      ],
      [
        "Expression , ArgumentList",
        "  $$ = $1; "
      ]
    ],
    "EmptyBrackets_opt": [
      "",
      "tEMPTYBRACKETS"
    ],
    "Expression": [
      [
        "EqvExpression",
        " $$ = $1; "
      ],
      [
        "Expression tIMP EqvExpression",
        " $$ = new_binary_expression(EXPR_IMP, $1, $3); ; "
      ]
    ],
    "EqvExpression": [
      [
        "XorExpression",
        " $$ = $1; "
      ],
      [
        "EqvExpression tEQV XorExpression",
        " $$ = new_binary_expression(EXPR_EQV, $1, $3); ; "
      ]
    ],
    "XorExpression": [
      [
        "OrExpression",
        " $$ = $1; "
      ],
      [
        "XorExpression tXOR OrExpression",
        " $$ = new_binary_expression(EXPR_XOR, $1, $3); ; "
      ]
    ],
    "OrExpression": [
      [
        "AndExpression",
        " $$ = $1; "
      ],
      [
        "OrExpression tOR AndExpression",
        " $$ = new_binary_expression(EXPR_OR, $1, $3); ; "
      ]
    ],
    "AndExpression": [
      [
        "NotExpression",
        " $$ = $1; "
      ],
      [
        "AndExpression tAND NotExpression",
        " $$ = new_binary_expression(EXPR_AND, $1, $3); ; "
      ]
    ],
    "NotExpression": [
      [
        "EqualityExpression",
        " $$ = $1; "
      ],
      [
        "tNOT NotExpression",
        " $$ = new_unary_expression(EXPR_NOT, $2); ; "
      ]
    ],
    "EqualityExpression": [
      [
        "ConcatExpression",
        " $$ = $1; "
      ],
      [
        "EqualityExpression = ConcatExpression",
        " $$ = new_binary_expression(EXPR_EQUAL, $1, $3); ; "
      ],
      [
        "EqualityExpression tNEQ ConcatExpression",
        " $$ = new_binary_expression(EXPR_NEQUAL, $1, $3); ; "
      ],
      [
        "EqualityExpression > ConcatExpression",
        " $$ = new_binary_expression(EXPR_GT, $1, $3); ; "
      ],
      [
        "EqualityExpression < ConcatExpression",
        " $$ = new_binary_expression($2, $1, $3); ; "
      ],
      [
        "EqualityExpression tGTEQ ConcatExpression",
        " $$ = new_binary_expression(EXPR_GTEQ, $1, $3); ; "
      ],
      [
        "EqualityExpression tLTEQ ConcatExpression",
        " $$ = new_binary_expression($2, $1, $3); ; "
      ],
      [
        "EqualityExpression tIS ConcatExpression",
        " $$ = new_binary_expression(EXPR_IS, $1, $3); ; "
      ]
    ],
    "ConcatExpression": [
      [
        "AdditiveExpression",
        " $$ = $1; "
      ],
      [
        "ConcatExpression & AdditiveExpression",
        " $$ = new_binary_expression(EXPR_CONCAT, $1, $3); CHECK_ERROR; "
      ]
    ],
    "AdditiveExpression": [
      [
        "ModExpression",
        " $$ = $1; "
      ],
      [
        "AdditiveExpression + ModExpression",
        " $$ = new_binary_expression(EXPR_ADD, $1, $3); CHECK_ERROR; "
      ],
      [
        "AdditiveExpression - ModExpression",
        " $$ = new_binary_expression(EXPR_SUB, $1, $3); CHECK_ERROR; "
      ]
    ],
    "ModExpression": [
      [
        "IntdivExpression",
        " $$ = $1; "
      ],
      [
        "ModExpression tMOD IntdivExpression",
        " $$ = new_binary_expression(EXPR_MOD, $1, $3); CHECK_ERROR; "
      ]
    ],
    "IntdivExpression": [
      [
        "MultiplicativeExpression",
        " $$ = $1; "
      ],
      [
        "IntdivExpression \\\\ MultiplicativeExpression",
        " $$ = new_binary_expression(EXPR_IDIV, $1, $3); CHECK_ERROR; "
      ]
    ],
    "MultiplicativeExpression": [
      [
        "ExpExpression",
        " $$ = $1; "
      ],
      [
        "MultiplicativeExpression * ExpExpression",
        " $$ = new_binary_expression(EXPR_MUL, $1, $3); CHECK_ERROR; "
      ],
      [
        "MultiplicativeExpression / ExpExpression",
        " $$ = new_binary_expression(EXPR_DIV, $1, $3); CHECK_ERROR; "
      ]
    ],
    "ExpExpression": [
      [
        "UnaryExpression",
        " $$ = $1; "
      ],
      [
        "ExpExpression ^ UnaryExpression",
        " $$ = new_binary_expression(EXPR_EXP, $1, $3); CHECK_ERROR; "
      ]
    ],
    "UnaryExpression": [
      [
        "LiteralExpression",
        " $$ = $1; "
      ],
      [
        "CallExpression",
        " $$ = $1; "
      ],
      [
        "tNEW tIdentifier",
        " $$ = new_new_expression($2); CHECK_ERROR; "
      ],
      [
        "- UnaryExpression",
        " $$ = new_unary_expression(EXPR_NEG, $2); CHECK_ERROR; "
      ]
    ],
    "CallExpression": [
      [
        "PrimaryExpression",
        " $$ = $1; "
      ],
      [
        "MemberExpression Arguments_opt",
        "  $$ = $1; "
      ]
    ],
    "LiteralExpression": [
      [
        "tTRUE",
        " $$ = new_bool_expression(VARIANT_TRUE); CHECK_ERROR; "
      ],
      [
        "tFALSE",
        " $$ = new_bool_expression(VARIANT_FALSE); CHECK_ERROR; "
      ],
      [
        "tString",
        " $$ = new_string_expression($1); CHECK_ERROR; "
      ],
      [
        "tShort",
        " $$ = new_long_expression(EXPR_USHORT, $1); CHECK_ERROR; "
      ],
      [
        "0",
        " $$ = new_long_expression(EXPR_USHORT, 0); CHECK_ERROR; "
      ],
      [
        "tLong",
        " $$ = new_long_expression(EXPR_ULONG, $1); CHECK_ERROR; "
      ],
      [
        "tDouble",
        " $$ = new_double_expression($1); CHECK_ERROR; "
      ],
      [
        "tEMPTY",
        " $$ = new_expression(EXPR_EMPTY, 0); CHECK_ERROR; "
      ],
      [
        "tnull",
        " $$ = new_expression(EXPR_null, 0); CHECK_ERROR; "
      ],
      [
        "tNOTHING",
        " $$ = new_expression(EXPR_NOTHING, 0); CHECK_ERROR; "
      ]
    ],
    "PrimaryExpression": [
      [
        "( Expression )",
        " $$ = $2; "
      ],
      [
        "tME",
        " $$ = new_expression(EXPR_ME, 0); CHECK_ERROR; "
      ]
    ],
    "ClassDeclaration": [
      [
        "tCLASS tIdentifier tNL ClassBody tEND tCLASS tNL",
        "  $$ = $4; "
      ]
    ],
    "ClassBody": [
      [
        "",
        " $$ = new_class_decl(ctx); "
      ],
      [
        "FunctionDecl tNL ClassBody",
        " $$ = add_class_function($3, $1); CHECK_ERROR; "
      ],
      [
        "Storage tIdentifier tNL ClassBody",
        " $$ = add_variant_prop($4, $2, $1); CHECK_ERROR; "
      ],
      [
        "PropertyDecl tNL ClassBody",
        " $$ = add_class_function($3, $1); CHECK_ERROR; "
      ]
    ],
    "PropertyDecl": [
      [
        "Storage_opt tPROPERTY tGET tIdentifier EmptyBrackets_opt tNL StatementsNl_opt tEND tPROPERTY",
        " $$ = new_function_decl($4, FUNC_PROPGET, $1, null, $7); CHECK_ERROR; "
      ],
      [
        "Storage_opt tPROPERTY tLET tIdentifier ( ArgumentDecl ) tNL StatementsNl_opt tEND tPROPERTY",
        " $$ = new_function_decl($4, FUNC_PROPLET, $1, $6, $9); CHECK_ERROR; "
      ],
      [
        "Storage_opt tPROPERTY tSET tIdentifier ( ArgumentDecl ) tNL StatementsNl_opt tEND tPROPERTY",
        " $$ = new_function_decl($4, FUNC_PROPSET, $1, $6, $9); CHECK_ERROR; "
      ]
    ],
    "FunctionDecl": [
      [
        "Storage_opt tSUB tIdentifier ArgumentsDecl_opt tNL StatementsNl_opt tEND tSUB",
        " $$ = new_function_decl($3, FUNC_SUB, $1, $4, $6); CHECK_ERROR; "
      ],
      [
        "Storage_opt tFUNCTION tIdentifier ArgumentsDecl_opt tNL StatementsNl_opt tEND tFUNCTION",
        " $$ = new_function_decl($3, FUNC_FUNCTION, $1, $4, $6); CHECK_ERROR; "
      ]
    ],
    "Storage_opt": [
      [
        "",
        " $$ = 0; "
      ],
      [
        "Storage",
        " $$ = $1; "
      ]
    ],
    "Storage": [
      [
        "tPUBLIC tDEFAULT",
        " $$ = STORAGE_IS_DEFAULT; "
      ],
      [
        "tPUBLIC",
        " $$ = 0; "
      ],
      [
        "tPRIVATE",
        " $$ = STORAGE_IS_PRIVATE; "
      ]
    ],
    "ArgumentsDecl_opt": [
      [
        "EmptyBrackets_opt",
        " $$ = null; "
      ],
      [
        "( ArgumentDeclList )",
        " $$ = $2; "
      ]
    ],
    "ArgumentDeclList": [
      [
        "ArgumentDecl",
        " $$ = $1; "
      ],
      [
        "ArgumentDecl COMMA ArgumentDeclList",
        " $$ = $1; "
      ]
    ],
    "ArgumentDecl": [
      [
        "tIdentifier",
        " $$ = new_argument_decl($1, true); "
      ],
      [
        "tBYREF tIdentifier",
        " $$ = new_argument_decl($2, true); "
      ],
      [
        "tBYVAL tIdentifier",
        " $$ = new_argument_decl($2, false); "
      ]
    ]
  },
  "moduleInclude": "\n\nfunction parser_error(str) {\n  console.log(\"Parse Error, yo: \" + str);\n}\n\nfunction parse_complete(prg) {\n  console.log(\"program complete: \" + prg);\n}\n\nfunction new_argument_decl(name, by_ref) {\n  console.log(\"function parameter: \" + name);\n/*\n    arg_decl_t *arg_decl;\n\n    arg_decl = parser_alloc(ctx, sizeof(*arg_decl));\n    if(!arg_decl)\n        return null;\n\n    arg_decl->name = name;\n    arg_decl->by_ref = by_ref;\n    arg_decl->next = null;\n    return arg_decl;\n*/\n}\n\n\nfunction new_member_expression(obj_expr, identifier) {\n  console.log(\"new member expression.. object: \" + obj_expr + \" ident: \" + identifier);\n/*\n    member_expression_t *expr;\n\n    expr = new_expression(ctx, EXPR_MEMBER, sizeof(*expr));\n    if(!expr)\n        return null;\n\n    expr->obj_expr = obj_expr;\n    expr->identifier = identifier;\n    expr->args = null;\n    return expr;\n*/\n}\n\nfunction new_binary_expression(x, y, z) {\n}\n\nfunction source_add_statement(ctx, stat) {\n    console.log(stat);\n/*\n    if(!stat)\n        return;\n\n    if(ctx->stats) {\n        ctx->stats_tail->next = stat;\n        ctx->stats_tail = stat;\n    }else {\n        ctx->stats = ctx->stats_tail = stat;\n    }\n*/\n}\n\n/*\nstatic void source_add_class(parser_ctx_t *ctx, class_decl_t *class_decl)\n{\n    class_decl->next = ctx->class_decls;\n    ctx->class_decls = class_decl;\n}\n\nstatic void parse_complete(parser_ctx_t *ctx, BOOL option_explicit)\n{\n    ctx->parse_complete = TRUE;\n    ctx->option_explicit = option_explicit;\n}\n\nstatic void *new_expression(parser_ctx_t *ctx, expression_type_t type, size_t size)\n{\n    expression_t *expr;\n\n    expr = parser_alloc(ctx, size ? size : sizeof(*expr));\n    if(expr) {\n        expr->type = type;\n        expr->next = null;\n    }\n\n    return expr;\n}\n\nstatic expression_t *new_bool_expression(parser_ctx_t *ctx, VARIANT_BOOL value)\n{\n    bool_expression_t *expr;\n\n    expr = new_expression(ctx, EXPR_BOOL, sizeof(*expr));\n    if(!expr)\n        return null;\n\n    expr->value = value;\n    return &expr->expr;\n}\n\nstatic expression_t *new_string_expression(parser_ctx_t *ctx, const WCHAR *value)\n{\n    string_expression_t *expr;\n\n    expr = new_expression(ctx, EXPR_STRING, sizeof(*expr));\n    if(!expr)\n        return null;\n\n    expr->value = value;\n    return &expr->expr;\n}\n\nstatic expression_t *new_long_expression(parser_ctx_t *ctx, expression_type_t type, LONG value)\n{\n    int_expression_t *expr;\n\n    expr = new_expression(ctx, type, sizeof(*expr));\n    if(!expr)\n        return null;\n\n    expr->value = value;\n    return &expr->expr;\n}\n\nstatic expression_t *new_double_expression(parser_ctx_t *ctx, double value)\n{\n    double_expression_t *expr;\n\n    expr = new_expression(ctx, EXPR_DOUBLE, sizeof(*expr));\n    if(!expr)\n        return null;\n\n    expr->value = value;\n    return &expr->expr;\n}\n\nstatic expression_t *new_unary_expression(parser_ctx_t *ctx, expression_type_t type, expression_t *subexpr)\n{\n    unary_expression_t *expr;\n\n    expr = new_expression(ctx, type, sizeof(*expr));\n    if(!expr)\n        return null;\n\n    expr->subexpr = subexpr;\n    return &expr->expr;\n}\n\nstatic expression_t *new_binary_expression(parser_ctx_t *ctx, expression_type_t type, expression_t *left, expression_t *right)\n{\n    binary_expression_t *expr;\n\n    expr = new_expression(ctx, type, sizeof(*expr));\n    if(!expr)\n        return null;\n\n    expr->left = left;\n    expr->right = right;\n    return &expr->expr;\n}\n\nstatic member_expression_t *new_member_expression(parser_ctx_t *ctx, expression_t *obj_expr, const WCHAR *identifier)\n{\n    member_expression_t *expr;\n\n    expr = new_expression(ctx, EXPR_MEMBER, sizeof(*expr));\n    if(!expr)\n        return null;\n\n    expr->obj_expr = obj_expr;\n    expr->identifier = identifier;\n    expr->args = null;\n    return expr;\n}\n\nstatic expression_t *new_new_expression(parser_ctx_t *ctx, const WCHAR *identifier)\n{\n    string_expression_t *expr;\n\n    expr = new_expression(ctx, EXPR_NEW, sizeof(*expr));\n    if(!expr)\n        return null;\n\n    expr->value = identifier;\n    return &expr->expr;\n}\n\nstatic void *new_statement(parser_ctx_t *ctx, statement_type_t type, size_t size)\n{\n    statement_t *stat;\n\n    stat = parser_alloc(ctx, size ? size : sizeof(*stat));\n    if(stat) {\n        stat->type = type;\n        stat->next = null;\n    }\n\n    return stat;\n}\n\nstatic statement_t *new_call_statement(parser_ctx_t *ctx, member_expression_t *expr)\n{\n    call_statement_t *stat;\n\n    stat = new_statement(ctx, STAT_CALL, sizeof(*stat));\n    if(!stat)\n        return null;\n\n    stat->expr = expr;\n    return &stat->stat;\n}\n\nstatic statement_t *new_assign_statement(parser_ctx_t *ctx, member_expression_t *left, expression_t *right)\n{\n    assign_statement_t *stat;\n\n    stat = new_statement(ctx, STAT_ASSIGN, sizeof(*stat));\n    if(!stat)\n        return null;\n\n    stat->member_expr = left;\n    stat->value_expr = right;\n    return &stat->stat;\n}\n\nstatic statement_t *new_set_statement(parser_ctx_t *ctx, member_expression_t *left, expression_t *right)\n{\n    assign_statement_t *stat;\n\n    stat = new_statement(ctx, STAT_SET, sizeof(*stat));\n    if(!stat)\n        return null;\n\n    stat->member_expr = left;\n    stat->value_expr = right;\n    return &stat->stat;\n}\n\nstatic dim_decl_t *new_dim_decl(parser_ctx_t *ctx, const WCHAR *name, dim_decl_t *next)\n{\n    dim_decl_t *decl;\n\n    decl = parser_alloc(ctx, sizeof(*decl));\n    if(!decl)\n        return null;\n\n    decl->name = name;\n    decl->next = next;\n    return decl;\n}\n\nstatic statement_t *new_dim_statement(parser_ctx_t *ctx, dim_decl_t *decls)\n{\n    dim_statement_t *stat;\n\n    stat = new_statement(ctx, STAT_DIM, sizeof(*stat));\n    if(!stat)\n        return null;\n\n    stat->dim_decls = decls;\n    return &stat->stat;\n}\n\nstatic elseif_decl_t *new_elseif_decl(parser_ctx_t *ctx, expression_t *expr, statement_t *stat)\n{\n    elseif_decl_t *decl;\n\n    decl = parser_alloc(ctx, sizeof(*decl));\n    if(!decl)\n        return null;\n\n    decl->expr = expr;\n    decl->stat = stat;\n    decl->next = null;\n    return decl;\n}\n\nstatic statement_t *new_while_statement(parser_ctx_t *ctx, statement_type_t type, expression_t *expr, statement_t *body)\n{\n    while_statement_t *stat;\n\n    stat = new_statement(ctx, type, sizeof(*stat));\n    if(!stat)\n        return null;\n\n    stat->expr = expr;\n    stat->body = body;\n    return &stat->stat;\n}\n\nstatic statement_t *new_forto_statement(parser_ctx_t *ctx, const WCHAR *identifier, expression_t *from_expr,\n        expression_t *to_expr, expression_t *step_expr, statement_t *body)\n{\n    forto_statement_t *stat;\n\n    stat = new_statement(ctx, STAT_FORTO, sizeof(*stat));\n    if(!stat)\n        return null;\n\n    stat->identifier = identifier;\n    stat->from_expr = from_expr;\n    stat->to_expr = to_expr;\n    stat->step_expr = step_expr;\n    stat->body = body;\n    return &stat->stat;\n}\n\nstatic statement_t *new_foreach_statement(parser_ctx_t *ctx, const WCHAR *identifier, expression_t *group_expr,\n        statement_t *body)\n{\n    foreach_statement_t *stat;\n\n    stat = new_statement(ctx, STAT_FOREACH, sizeof(*stat));\n    if(!stat)\n        return null;\n\n    stat->identifier = identifier;\n    stat->group_expr = group_expr;\n    stat->body = body;\n    return &stat->stat;\n}\n\nstatic statement_t *new_if_statement(parser_ctx_t *ctx, expression_t *expr, statement_t *if_stat, elseif_decl_t *elseif_decl,\n        statement_t *else_stat)\n{\n    if_statement_t *stat;\n\n    stat = new_statement(ctx, STAT_IF, sizeof(*stat));\n    if(!stat)\n        return null;\n\n    stat->expr = expr;\n    stat->if_stat = if_stat;\n    stat->elseifs = elseif_decl;\n    stat->else_stat = else_stat;\n    return &stat->stat;\n}\n\nstatic statement_t *new_onerror_statement(parser_ctx_t *ctx, BOOL resume_next)\n{\n    onerror_statement_t *stat;\n\n    stat = new_statement(ctx, STAT_ONERROR, sizeof(*stat));\n    if(!stat)\n        return null;\n\n    stat->resume_next = resume_next;\n    return &stat->stat;\n}\n\nstatic arg_decl_t *new_argument_decl(parser_ctx_t *ctx, const WCHAR *name, BOOL by_ref)\n{\n    arg_decl_t *arg_decl;\n\n    arg_decl = parser_alloc(ctx, sizeof(*arg_decl));\n    if(!arg_decl)\n        return null;\n\n    arg_decl->name = name;\n    arg_decl->by_ref = by_ref;\n    arg_decl->next = null;\n    return arg_decl;\n}\n\nstatic function_decl_t *new_function_decl(parser_ctx_t *ctx, const WCHAR *name, function_type_t type,\n        unsigned storage_flags, arg_decl_t *arg_decl, statement_t *body)\n{\n    function_decl_t *decl;\n\n    if(storage_flags & STORAGE_IS_DEFAULT) {\n        if(type == FUNC_PROPGET) {\n            type = FUNC_DEFGET;\n        }else {\n            FIXME(\"Invalid default property\\n\");\n            ctx->hres = E_FAIL;\n            return null;\n        }\n    }\n\n    decl = parser_alloc(ctx, sizeof(*decl));\n    if(!decl)\n        return null;\n\n    decl->name = name;\n    decl->type = type;\n    decl->is_public = !(storage_flags & STORAGE_IS_PRIVATE);\n    decl->args = arg_decl;\n    decl->body = body;\n    decl->next = null;\n    decl->next_prop_func = null;\n    return decl;\n}\n\nstatic statement_t *new_function_statement(parser_ctx_t *ctx, function_decl_t *decl)\n{\n    function_statement_t *stat;\n\n    stat = new_statement(ctx, STAT_FUNC, sizeof(*stat));\n    if(!stat)\n        return null;\n\n    stat->func_decl = decl;\n    return &stat->stat;\n}\n\nstatic class_decl_t *new_class_decl(parser_ctx_t *ctx)\n{\n    class_decl_t *class_decl;\n\n    class_decl = parser_alloc(ctx, sizeof(*class_decl));\n    if(!class_decl)\n        return null;\n\n    class_decl->funcs = null;\n    class_decl->props = null;\n    class_decl->next = null;\n    return class_decl;\n}\n\nstatic class_decl_t *add_class_function(parser_ctx_t *ctx, class_decl_t *class_decl, function_decl_t *decl)\n{\n    function_decl_t *iter;\n\n    for(iter = class_decl->funcs; iter; iter = iter->next) {\n        if(!strcmpiW(iter->name, decl->name)) {\n            if(decl->type == FUNC_SUB || decl->type == FUNC_FUNCTION) {\n                FIXME(\"Redefinition of %s::%s\\n\", debugstr_w(class_decl->name), debugstr_w(decl->name));\n                ctx->hres = E_FAIL;\n                return null;\n            }\n\n            while(1) {\n                if(iter->type == decl->type) {\n                    FIXME(\"Redefinition of %s::%s\\n\", debugstr_w(class_decl->name), debugstr_w(decl->name));\n                    ctx->hres = E_FAIL;\n                    return null;\n                }\n                if(!iter->next_prop_func)\n                    break;\n                iter = iter->next_prop_func;\n            }\n\n            iter->next_prop_func = decl;\n            return class_decl;\n        }\n    }\n\n    decl->next = class_decl->funcs;\n    class_decl->funcs = decl;\n    return class_decl;\n}\n\nstatic class_decl_t *add_variant_prop(parser_ctx_t *ctx, class_decl_t *class_decl, const WCHAR *identifier, unsigned storage_flags)\n{\n    class_prop_decl_t *prop;\n\n    if(storage_flags & STORAGE_IS_DEFAULT) {\n        FIXME(\"variant prop van't be default value\\n\");\n        ctx->hres = E_FAIL;\n        return null;\n    }\n\n    prop = parser_alloc(ctx, sizeof(*prop));\n    if(!prop)\n        return null;\n\n    prop->name = identifier;\n    prop->is_public = !(storage_flags & STORAGE_IS_PRIVATE);\n    prop->next = class_decl->props;\n    class_decl->props = prop;\n    return class_decl;\n}\n\nstatic const_decl_t *new_const_decl(parser_ctx_t *ctx, const WCHAR *name, expression_t *expr)\n{\n    const_decl_t *decl;\n\n    decl = parser_alloc(ctx, sizeof(*decl));\n    if(!decl)\n        return null;\n\n    decl->name = name;\n    decl->value_expr = expr;\n    decl->next = null;\n    return decl;\n}\n\nstatic statement_t *new_const_statement(parser_ctx_t *ctx, const_decl_t *decls)\n{\n    const_statement_t *stat;\n\n    stat = new_statement(ctx, STAT_CONST, sizeof(*stat));\n    if(!stat)\n        return null;\n\n    stat->decls = decls;\n    return &stat->stat;\n}\n\nstatic statement_t *link_statements(statement_t *head, statement_t *tail)\n{\n    statement_t *iter;\n\n    for(iter = head; iter->next; iter = iter->next);\n    iter->next = tail;\n\n    return head;\n}\n\nvoid *parser_alloc(parser_ctx_t *ctx, size_t size)\n{\n    void *ret;\n\n    ret = vbsheap_alloc(&ctx->heap, size);\n    if(!ret)\n        ctx->hres = E_OUTOFMEMORY;\n    return ret;\n}\n\nHRESULT parse_script(parser_ctx_t *ctx, const WCHAR *code)\n{\n    ctx->code = ctx->ptr = code;\n    ctx->end = ctx->code + strlenW(ctx->code);\n\n    vbsheap_init(&ctx->heap);\n\n    ctx->parse_complete = FALSE;\n    ctx->hres = S_OK;\n\n    ctx->last_token = tNL;\n    ctx->last_nl = 0;\n    ctx->stats = ctx->stats_tail = null;\n    ctx->class_decls = null;\n    ctx->option_explicit = FALSE;\n\n    parser_parse(ctx);\n\n    if(FAILED(ctx->hres))\n        return ctx->hres;\n    if(!ctx->parse_complete) {\n        FIXME(\"parser failed on parsing %s\\n\", debugstr_w(ctx->ptr));\n        return E_FAIL;\n    }\n\n    return S_OK;\n}\n\nvoid parser_release(parser_ctx_t *ctx)\n{\n    vbsheap_free(&ctx->heap);\n}\n*/\n"
}